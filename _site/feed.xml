<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-25T16:00:51+08:00</updated><id>http://localhost:4000/</id><title type="html">Estadistika</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Model Productization: Crafting a Web Application for Iris Model</title><link href="http://localhost:4000/julia/python/software-engineering/ui-ux/model-deployment/productization/2019/07/10/Model-Productization-Creating-a-Web-Application-for-Iris-Model.html" rel="alternate" type="text/html" title="Model Productization: Crafting a Web Application for Iris Model" /><published>2019-07-10T12:00:00+08:00</published><updated>2019-07-10T12:00:00+08:00</updated><id>http://localhost:4000/julia/python/software-engineering/ui-ux/model-deployment/productization/2019/07/10/Model%20Productization-Creating%20a%20Web%20Application%20for%20Iris%20Model</id><content type="html" xml:base="http://localhost:4000/julia/python/software-engineering/ui-ux/model-deployment/productization/2019/07/10/Model-Productization-Creating-a-Web-Application-for-Iris-Model.html">&lt;p&gt;Any successful data science project must end with productization. This is the stage where trained models are deployed as application that can be easily accessed by the end users. The application can either be part of already existing system, or it could also be a standalone application working in the back-end of any interface. In any case, this part of the project deals mainly with software engineering — a task that involves front-end programming.&lt;/p&gt;

&lt;p&gt;In my previous article, we talked about data engineering by &lt;a href=&quot;https://estadistika.github.io/julia/python/packages/relational-databases/2019/07/07/Interfacing-with-Relational-Database-using-MySQL.jl-and-PyMySQL.html&quot;&gt;interfacing with relational database using MySQL.jl and PyMySQL&lt;/a&gt;; and we’ve done &lt;a href=&quot;https://estadistika.github.io/data/analyses/wrangling/julia/programming/packages/2018/06/08/Julia-Introduction-to-Data-Wrangling.html&quot;&gt;data wrangling&lt;/a&gt; as well. Moreover,  we also touched on modeling using &lt;a href=&quot;https://estadistika.github.io/julia/python/packages/knet/flux/tensorflow/machine-learning/deep-learning/2019/06/20/Deep-Learning-Exploring-High-Level-APIs-of-Knet.jl-and-Flux.jl-in-comparison-to-Tensorflow-Keras.html&quot;&gt;Multilayer Perceptron (MLP) for classifying the Iris species&lt;/a&gt;. Hence to cover the end-to-end spectrum of a typical data science project (excluding the business part), we’re going to deploy our trained Iris model as a web application.&lt;/p&gt;

&lt;p&gt;There are of course several options for user-interface other than web, for example desktop and mobile front-ends; but I personally prefer web-based since you can access the application without having to install anything — only web browser.&lt;/p&gt;
&lt;h3 id=&quot;final-output&quot;&gt;Final Output&lt;/h3&gt;
&lt;p&gt;The final interface of our application is given below. The app is powered by a server on both ends, with two models (Julia and Python) running in the back-end. Try playing with the app to see how it works.&lt;/p&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;747&quot; data-theme-id=&quot;dark&quot; data-default-tab=&quot;result&quot; data-user=&quot;alstat&quot; data-slug-hash=&quot;YoMMOY&quot; style=&quot;height: 550px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot; data-pen-title=&quot;Tutorial&quot;&gt;
  &lt;span&gt;See the Pen &lt;a href=&quot;https://codepen.io/alstat/pen/YoMMOY/&quot;&gt;
  Tutorial&lt;/a&gt; by Al Asaad (&lt;a href=&quot;https://codepen.io/alstat&quot;&gt;@alstat&lt;/a&gt;)
  on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
&lt;/p&gt;
&lt;script async=&quot;&quot; src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;As indicated in the status pane of the application, the UI above is not powered by the back-end servers. That is, the prediction is not coming from the model, but rather randomly sampled from a set of possible values of Iris species, i.e. Setosa, Versicolor, and Virginica. The same case when estimating the model, the app simply mimics the model training. This is because I don’t have a cloud server, so this only works in the local server in my machine. The application above, however, does send request to the server (localhost:8081 and port 8082, in this case), but if unaccessible, then it will randomly sample from the set of species when classifying; and randomly generates a test accuracy when training — and this is why we still get prediction despite no communication to the back-end servers. In succeeding sections though, I will show you (via screencast) how the application works with the back-end servers.&lt;/p&gt;

&lt;h3 id=&quot;project-source-codes&quot;&gt;Project Source Codes&lt;/h3&gt;
&lt;p&gt;The complete codes for this article are available &lt;a href=&quot;https://github.com/estadistika/projects/tree/master/2019-07-25-Iris-Web-App/model-deployment&quot;&gt;here&lt;/a&gt; as a Github repo, and I encourage you to have it in your machine if you want to follow the succeeding discussions. The repo has the following folder tree structure:
&lt;script src=&quot;https://gist.github.com/alstat/1c5b9f777d05373f1be8801dc2bb100c.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;software-architecture&quot;&gt;Software Architecture&lt;/h3&gt;
&lt;p&gt;As mentioned earlier, the application is powered by back-end servers that are instances of Julia and Python. The communication between the user-interface (client) and the servers is done via HTTP (HyperText Transfer Protocol). The following is the architecture of our application:
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1VdJFUubWb6Hc9q2960XFv7FUg-K5ieYe&quot; /&gt;
As shown in the figure, the client side handles response asynchronously. That is, we can send multiple request without waiting for the response of the preceding request. On the other hand, the server side processes the request synchronously, that is, the request from the client are handled one-at-a-time. These networks work via &lt;a href=&quot;https://github.com/JuliaWeb/HTTP.jl&quot;&gt;HTTP.jl&lt;/a&gt; for Julia, and &lt;a href=&quot;https://palletsprojects.com/p/flask/&quot;&gt;Flask&lt;/a&gt; for Python. If you are interested in asynchronous back-end server, checkout Python’s &lt;a href=&quot;https://klein.readthedocs.io/en/latest/&quot;&gt;Klein&lt;/a&gt; library (Flask only works synchronously); and for Julia you can set HTTP.jl to work asynchronously. I should mention though that HTTP.jl is a bit lower in terms of API level compared to Flask. In fact, HTTP.jl is better compared to Python’s &lt;a href=&quot;https://2.python-requests.org/en/master/&quot;&gt;Requests&lt;/a&gt; library. For Flask counterpart, however, Julia offers &lt;a href=&quot;https://github.com/GenieFramework/Genie.jl&quot;&gt;Genie.jl&lt;/a&gt; and I encourage you to check that out as well.&lt;/p&gt;

&lt;h3 id=&quot;hypertext-transfer-protocol-http&quot;&gt;HyperText Transfer Protocol (HTTP)&lt;/h3&gt;
&lt;p&gt;We’ve emphasized in the previous section that, the communication between the interface and the model is done via HTTP. In this section, we’ll attempt to briefly cover the basics of this protocol. To do this, we’ll setup a client and server instances both in Julia and in Python. This is done by first running the server in the Terminal/CMD, before running the client in a separate Terminal/CMD (follow the order, execute the server first before the client). Here are the codes:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-072019-1', 'tabcontent-1')&quot;&gt;Julia (Client)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-072019-2', 'tabcontent-1')&quot;&gt;Julia (Server)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-072019-1', 'tabcontent-1')&quot;&gt;Python (Client)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-072019-2', 'tabcontent-1')&quot;&gt;Python (Server)&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-072019-1&quot; class=&quot;tabcontent-1 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/efd32b484f5c3066db4aba073d7232e5.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-072019-2&quot; class=&quot;tabcontent-1&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/14ac41a9aa0e4f84636dfe0d225e40ab.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-072019-1&quot; class=&quot;tabcontent-1&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/4a1b41e4ea3cf56dcbbd627245c079fd.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-072019-2&quot; class=&quot;tabcontent-1&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/47b77733fb514036c1c7483ff4e2eb33.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;For your reference, here are the outputs of the above codes.&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-072019-output-1', 'tabcontent-1-out')&quot;&gt;Julia (Output)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-072019-output-1', 'tabcontent-1-out')&quot;&gt;Python (Output)&lt;/button&gt;
&lt;/div&gt;
&lt;div id=&quot;julia-072019-output-1&quot; class=&quot;tabcontent-1-out first&quot;&gt;
  &lt;img id=&quot;julia-output&quot; src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1gpJIaqpP7Y4dye0-2dtGLEglcjvcezG0&quot; style=&quot;margin-top: 16px&quot; /&gt;
&lt;/div&gt;
&lt;div id=&quot;python-072019-output-1&quot; class=&quot;tabcontent-1-out&quot; style=&quot;display: none;&quot;&gt;
  &lt;img id=&quot;python-output&quot; src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1vqYNskzKAJiZGfYTmh0gQoshjUI6F88h&quot; style=&quot;margin-top: 16px&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;As shown in the screenshot above, the codes were executed at the root folder of the project (see the Project Source Codes section for folder tree structure). The server we setup is running at localhost:8081 or 127.0.0.1:8081 — waiting (or listening) for any incoming request from the client. Thus, when we ran the client codes, which send POST request with the data &lt;code&gt;{&quot;Hello&quot; : &quot;World&quot;}&lt;/code&gt; to localhost:8081, the server immediately responded back to the client — throwing the data received. The header specified in the response, &lt;code&gt;&quot;Access-Control-Allow-Origin&quot; =&amp;gt; &quot;*&quot;&lt;/code&gt;, simply tells the server to respond to any (&lt;code&gt;*&lt;/code&gt;) clients. For more details on HTTP, I think &lt;a href=&quot;https://www.youtube.com/watch?v=eesqK59rhGA&quot;&gt;this video&lt;/a&gt; is useful.&lt;/p&gt;
&lt;h3 id=&quot;server-iris-classifier&quot;&gt;Server: Iris Classifier&lt;/h3&gt;
&lt;p&gt;At this point, you should have at least an idea of how HTTP works, since we’ll set this up in Julia and in Python. The codes for the REST API are given below:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-072019-3', 'tabcontent-2')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-072019-3', 'tabcontent-2')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-072019-3&quot; class=&quot;tabcontent-2 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/0b6a33e478979665e9adf10c17969f92.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-072019-3&quot; class=&quot;tabcontent-2&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/d1099efc4d6071488b16f5dbf17bcaee.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;The requests are received at line 38 of the Julia code, and are handled depending on the target URL. If the target URL of the client’s request is &lt;code&gt;/classify&lt;/code&gt;, then the &lt;code&gt;classifier&lt;/code&gt; router will handle the request via the &lt;code&gt;classify&lt;/code&gt; function defined in line 7. The same case when we receive training request, the &lt;code&gt;train&lt;/code&gt; function defined in line 19 will handle the request. Each of these functions then returns a response back to the client with the data. On the other hand, we see that Python’s Flask library uses a decorator for specifying the router, with two main helper functions defined in line 32 and 37. The two approaches are indeed easy to follow, despite the difference implementation. I should emphasize though that the above codes refer to other files to perform the training and classification. These files include &lt;i&gt;model-training.jl&lt;/i&gt; and &lt;i&gt;model_training.py&lt;/i&gt;, etc. I will leave these to the reader to explore the scripts in the project repo.&lt;/p&gt;
&lt;h3 id=&quot;client-web-interface&quot;&gt;Client: Web Interface&lt;/h3&gt;
&lt;p&gt;Now that we have an idea of how the request in the servers are processed, in this section, we need to understand how the client prepares and sends requests to the server, and how it processes the response. In the CodePen embedded above, the client codes are in the JS (Javascript) tab. The following is a copy of it:
&lt;script src=&quot;https://gist.github.com/alstat/b53164002475b06c559a0b9cc1177365.js&quot;&gt;&lt;/script&gt;
Lines 23-28 define the event listener for the buttons in the application. Line 24, for example, adds functionality to the &lt;kbd&gt;Classify&lt;/kbd&gt; button, which is defined in Line 44. This is a void function, but it sends HTTP request in line 79 to the specified url defined in lines 63-67. The &lt;code&gt;httpRequest&lt;/code&gt; function in line 5, is the one that handles the communication with the servers. It takes three arguments, the &lt;code&gt;URL&lt;/code&gt; (the address of the server), the &lt;code&gt;data&lt;/code&gt; (the request data to be sent to the server), and the &lt;code&gt;callback&lt;/code&gt; (a function that will handle the response from the server). The request as mentioned is handled asynchronously, and is specified by the third argument — &lt;code&gt;true&lt;/code&gt; (asynchronous) — of the &lt;code&gt;xhr.open&lt;/code&gt; method defined in line 8. The rest of the codes are functions defining the functionalities of the buttons, status pane, output display, etc. of the app.&lt;/p&gt;

&lt;h3 id=&quot;htmlcss&quot;&gt;HTML/CSS&lt;/h3&gt;
&lt;p&gt;The other codes that are part of the application are the HTML and CSS files. I will leave these to the reader, since these codes are simply declarations of how the layout and style of the app should look like.&lt;/p&gt;

&lt;h3 id=&quot;screencast&quot;&gt;Screencast&lt;/h3&gt;
&lt;p&gt;The following video shows how to run the application:
&lt;!-- &lt;iframe width=&quot;100%&quot; height=&quot;400px&quot; src=&quot;https://www.youtube.com/watch?v=jxM_U9USkv4&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;&lt;/iframe&gt; --&gt;&lt;/p&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;400px&quot; src=&quot;https://www.youtube.com/embed/jxM_U9USkv4&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In any data science project, one of the goal is to create a prototype of the project. I’ve been using Python even for production, but never tested Julia yet. One of my concern was precompilation of the codes, but this exercise, simply shows that the precompilations as what we know in Julia, always happens in the first run.&lt;/p&gt;

&lt;h3 id=&quot;software-versions&quot;&gt;Software Versions&lt;/h3&gt;
&lt;script src=&quot;https://gist.github.com/alstat/65dab0d062ea0fd229b4aa23c18fcd21.js&quot;&gt;&lt;/script&gt;</content><author><name>Al-Ahmadgaid B. Asaad</name></author><category term="julia" /><category term="python" /><category term="software-engineering" /><summary type="html">Any successful data science project must end with productization. This is the stage where trained models are deployed as application that can be easily accessed by the end users. The application can either be part of already existing system, or it could also be a standalone application working in the back-end of any interface. In any case, this part of the project deals mainly with software engineering — a task that involves front-end programming.</summary></entry><entry><title type="html">Interfacing with Relational Database using MySQL.jl and PyMySQL</title><link href="http://localhost:4000/julia/python/packages/relational-databases/2019/07/07/Interfacing-with-Relational-Database-using-MySQL.jl-and-PyMySQL.html" rel="alternate" type="text/html" title="Interfacing with Relational Database using MySQL.jl and PyMySQL" /><published>2019-07-07T12:00:00+08:00</published><updated>2019-07-07T12:00:00+08:00</updated><id>http://localhost:4000/julia/python/packages/relational-databases/2019/07/07/Interfacing%20with%20Relational%20Database%20using%20MySQL.jl%20and%20PyMySQL</id><content type="html" xml:base="http://localhost:4000/julia/python/packages/relational-databases/2019/07/07/Interfacing-with-Relational-Database-using-MySQL.jl-and-PyMySQL.html">&lt;p&gt;Prior to the advent of computing, relational database can be thought of log books typically used for inventory and visitor’s time-in time-out. These books contain rows that define the item/transaction, and columns describing the features of each row. Indeed, these are the core attributes of any relational database. Unlike spreadsheets, which are used for handling small datasets, databases are mostly used for storing huge transactional data for later use. They run on a server and often at the backend of any user (client) interface such as websites and mobile applications. These applications communicate with database via processing servers (e.g. &lt;a href=&quot;http://flask.pocoo.org/&quot;&gt;Flask&lt;/a&gt; and &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;). The figure below illustrates the request and response communcations between client and servers.
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1cedn62AXe6LS-jxCjXBxCYmL1iDFRlYQ&quot; /&gt;
As mentioned earlier, databases are meant to store data for &lt;i&gt;later use&lt;/i&gt; — in the sense that we can use it as a response to client’s requests, such as viewing or data extraction for insights. In this article, we are interested in data extraction from the database. In particular, the objective is to illustrate how to send request to MySQL server, and how to process response both from Julia and Python.&lt;/p&gt;
&lt;h3 id=&quot;mysql-server-setup&quot;&gt;MySQL Server Setup&lt;/h3&gt;
&lt;p&gt;To start with, we need to setup MySQL server in our machine. Click the following link to download and install the application.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/document/d/1B3ol7-Hte08mqzB5J8dBn1wFlpkxZ1Lgb2W7OUpIu60/edit?usp=sharing&quot;&gt;MySQL Server Download and Installation on macOS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/document/d/1GaZ5dPOH9o5rQPmxFWjGS4ZmUjEEeDM497UdXwcEgco/edit?usp=sharing&quot;&gt;MySQL Server Download and Installation on Windows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that I recommend you to download the latest version of MySQL since the setup above is using the old version.&lt;/p&gt;
&lt;h3 id=&quot;query-creating-database&quot;&gt;Query: Creating Database&lt;/h3&gt;
&lt;p&gt;In order to appreciate what we are aiming in this article, we need to go through some basic SQL queries to understand what type of request to send to MySQL server. I’m using macOS, but the following should work on Windows as well. For macOS users, open the MySQL Server Shell by running &lt;code&gt;mysql -u root -p&lt;/code&gt; (hit &lt;kbd&gt;return&lt;/kbd&gt; or &lt;kbd&gt;enter&lt;/kbd&gt; , and type in your MySQL root password you specified during the installation setup from the previous section) in the terminal. For windows, try to look for it in the Start Menu.
&lt;!-- &lt;img src=&quot;http://drive.google.com/uc?export=view&amp;id=1wRuD_gG4tJpp1ZKj3jCbwbzWAtERSjsn&quot; style=&quot;margin: -4px auto -30px auto;&quot;&gt; --&gt;
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1hcAnM6KYuASiBhu5AzHqZpf2P1EBneYb&quot; style=&quot;margin: -4px auto -30px auto;&quot; /&gt;
&lt;!-- https://drive.google.com/file/d/1hcAnM6KYuASiBhu5AzHqZpf2P1EBneYb/view?usp=sharing --&gt;
From here, we are going to check the available databases in MySQL server. To do this, run the following:
&lt;script src=&quot;https://gist.github.com/alstat/1dbad1187130a31091aead6145dc0151.js&quot;&gt;&lt;/script&gt;
Indeed, there are four out-of-the-box defined databases already, and we don’t want to touch that. Instead, we are going to create our own database, let’s call it &lt;code&gt;tutorial&lt;/code&gt;. To do this, run the following codes:
&lt;script src=&quot;https://gist.github.com/alstat/3d62031b3a0f2f2236568ffe0b9ec189.js&quot;&gt;&lt;/script&gt;
The best thing about SQL syntax is that, everything is self-explanatory, except maybe for line 19, which simply confirmed that we are using &lt;code&gt;tutorial&lt;/code&gt; as our database.&lt;/p&gt;
&lt;h3 id=&quot;query-creating-table&quot;&gt;Query: Creating Table&lt;/h3&gt;
&lt;p&gt;Next is to create a table for our database, we are going to use the &lt;a href=&quot;https://halalanresults.abs-cbn.com/&quot;&gt;2019 Philippine Election results&lt;/a&gt; with columns: Last Name, First Name, Party, Votes. Further, for purpose of illustration, we are going to use the top 5 senators only.
&lt;script src=&quot;https://gist.github.com/alstat/79d2c2c420a781d14834ef2307413045.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;query-inserting-values&quot;&gt;Query: Inserting Values&lt;/h3&gt;
&lt;p&gt;The following codes will insert the top five senators from the 2019 Philippine election results.
&lt;script src=&quot;https://gist.github.com/alstat/771051ecfca7075229a965e5861353f8.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;query-show-data&quot;&gt;Query: Show Data&lt;/h3&gt;
&lt;p&gt;To view the encoded data, we simply select all (&lt;code&gt;*&lt;/code&gt;) the columns from the table.
&lt;script src=&quot;https://gist.github.com/alstat/dd620c5151a14261d8095d614d80b81a.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h2 id=&quot;mysql-clients-on-julia-and-python&quot;&gt;MySQL Clients on Julia and Python&lt;/h2&gt;
&lt;p&gt;In this section, we are going to interface with MySQL server on Julia and Python. This is possible using &lt;a href=&quot;https://github.com/JuliaDatabases/MySQL.jl&quot;&gt;MySQL.jl&lt;/a&gt; and &lt;a href=&quot;https://pymysql.readthedocs.io/en/latest/index.html&quot;&gt;PyMySQL&lt;/a&gt; libraries. To start with, install the necessary libraries as follows:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-1', 'tabcontent-1')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-1', 'tabcontent-1')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-1&quot; class=&quot;tabcontent-1 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/844cee7187081181baea0aeb13efafa7.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-1&quot; class=&quot;tabcontent-1&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/f38f27e23bc74549930bd439af5075f9.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;For this exercise, our goal is to save the &lt;a href=&quot;https://cran.r-project.org/web/packages/nycflights13/nycflights13.pdf&quot;&gt;NYC Flights (2013)&lt;/a&gt; data into the database and query it from Julia and Python.&lt;/p&gt;

&lt;h3 id=&quot;downloading-nyc-flights-data&quot;&gt;Downloading NYC Flights Data&lt;/h3&gt;
&lt;p&gt;I have a copy of the dataset on Github, and so the following code will download the said data:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-2', 'tabcontent-2')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-2', 'tabcontent-2')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-2&quot; class=&quot;tabcontent-2 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/c0cf42053baa058cb3336867d9040d1d.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-2&quot; class=&quot;tabcontent-2&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/47d181a0efd1a63b829eded83cfe7402.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;h3 id=&quot;connect-to-mysql-server&quot;&gt;Connect to MySQL Server&lt;/h3&gt;
&lt;p&gt;In order for the client to send request to MySQL server, the user/client needs to connect to it using the credentials set in the installation.&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-3', 'tabcontent-3')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-3', 'tabcontent-3')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-3&quot; class=&quot;tabcontent-3 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/ef8e9274a0abf17055fa1cd35e343b02.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-3&quot; class=&quot;tabcontent-3&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/e7b04fe16d4ae8f324ba2eab2fe3a47e.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;Note that you need to have a strong password, and this configuration should not be exposed to the public. The above snippets are meant for illustration.&lt;/p&gt;
&lt;h3 id=&quot;first-request&quot;&gt;First Request&lt;/h3&gt;
&lt;p&gt;To test the connection, let’s send our first request — to show the tables in the database:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-4', 'tabcontent-4')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-4', 'tabcontent-4')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-4&quot; class=&quot;tabcontent-4 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/ab4d2403017c7b0a2e57e87590b202ad.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-4&quot; class=&quot;tabcontent-4&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/84b1c60e618d93b00ab2294c13438c35.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;In Julia, the response is recieved as a MySQL.Query object and can be viewed using DataFrame. For Python, however, you will get a tuple object.&lt;/p&gt;
&lt;h3 id=&quot;create-nyc-flights-table&quot;&gt;Create NYC Flights Table&lt;/h3&gt;
&lt;p&gt;At this point, we can now create the table for our dataset. To do this, run the following:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-5', 'tabcontent-5')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-5', 'tabcontent-5')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-5&quot; class=&quot;tabcontent-5 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/edd6aff9b0d5fc9a45b808b36a2d3f95.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-5&quot; class=&quot;tabcontent-5&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/890fe4cdc2e50f694a749448594cb248.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;As shown in the previous section, sending request to the server both in Julia and in Python is done by simply using a string of SQL queries as input to MySQL.jl and PyMySQL APIs. Hence, the &lt;code&gt;query&lt;/code&gt; object (in line 3 of Julia code and line 4 of Python code) above, simply automates the concatenation of SQL query for creating a table. Having said, you can of course write the query manually. To check if we have indeed created the table, run the following codes:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-6', 'tabcontent-6')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-6', 'tabcontent-6')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-6&quot; class=&quot;tabcontent-6 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/3694845948496741bd3256729a1d8469.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-6&quot; class=&quot;tabcontent-6&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/789b5aae723486aee01b6c018e61c60a.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;As you can see, we’ve created it already, but with no entry yet.&lt;/p&gt;
&lt;h3 id=&quot;populating-the-table&quot;&gt;Populating the Table&lt;/h3&gt;
&lt;p&gt;Finally, we are going to populate the table in the database by inserting the values row by row.&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-7', 'tabcontent-7')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-7', 'tabcontent-7')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-7&quot; class=&quot;tabcontent-7 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/c8ee6c05a99d9cd0f4270dd8a8beb984.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-7&quot; class=&quot;tabcontent-7&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/2f22ad0b1dd5f3ed39f360d2244c32f7.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;From the above Julia code, the result of the &lt;code&gt;stmt&lt;/code&gt; is an SQL &lt;code&gt;INSERT&lt;/code&gt; query with placeholder values indicated by &lt;code&gt;?&lt;/code&gt;. The timed (&lt;code&gt;@time&lt;/code&gt; in Julia code) loop in line 9 above maps the values of the vector, one-to-one, to the elements (&lt;code&gt;?&lt;/code&gt;) of the tuple in &lt;code&gt;stmt&lt;/code&gt;. Having said, &lt;code&gt;MySQL.Stmt&lt;/code&gt; has no equivalent in PyMySQL. Further, one major difference between these libraries is that, PyMySQL will not populate the table even after executing all sorts of SQL queries unless you commit it (&lt;code&gt;con.commit&lt;/code&gt;), as shown above. This is contrary to MySQL.jl which automatically commits every execution of the SQL queries. I do like the idea of having &lt;code&gt;con.commit&lt;/code&gt; in PyMySQL, since this avoids accidental deletion or modification in the database, thus adding a layer of security. To check if we have indeed populated the table, run the following:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-062819-8', 'tabcontent-8')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-062819-8', 'tabcontent-8')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-062819-8&quot; class=&quot;tabcontent-8 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/40c790d0216614cdcbf41de31dfa4e1a.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-062819-8&quot; class=&quot;tabcontent-8&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/09cf619f91773599b9902ba77fde7d76.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;To disconnect from the server, run &lt;code&gt;MySQL.disconnect(con)&lt;/code&gt; (Julia) or &lt;code&gt;con.close()&lt;/code&gt; (Python).&lt;/p&gt;
&lt;h3 id=&quot;benchmark&quot;&gt;Benchmark&lt;/h3&gt;
&lt;p&gt;For the benchmark, I added a timelapse recorder in populating and reading the table in the previous section. The figure below summarizes the results.
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1fhMJg3qIPupf3xhvyCW1p5Ph7tzn7UAH&quot; /&gt;
The figure was plotted using &lt;a href=&quot;http://gadflyjl.org/stable/index.html&quot;&gt;Gadfly.jl&lt;/a&gt;. Install this package using &lt;code&gt;Pkg&lt;/code&gt; as described above (see the first code block under &lt;i&gt;MySQL Clients on Julia and Python&lt;/i&gt; section), along with &lt;a href=&quot;https://github.com/JuliaGraphics/Cairo.jl&quot;&gt;Cario.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGraphics/Fontconfig.jl&quot;&gt;Fontconfig.jl&lt;/a&gt;. The latter two packages are used to save the plot in PNG format. See the code below to reproduce:
&lt;script src=&quot;https://gist.github.com/alstat/370b6b9eb33089f52c3f2f721e10e5d2.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The aim of this article was simply to illustrate the usage of MySQL.jl APIs in comparison to the PyMySQL; and I would say both libraries have similarities in APIs (as expected) and are stable for the tasks. I should emphasize though that, I do like the &lt;code&gt;con.commit&lt;/code&gt; of PyMySQL since this adds a level of security, and I think this is a good addition to MySQL.jl in the future.&lt;/p&gt;

&lt;h3 id=&quot;complete-codes&quot;&gt;Complete Codes&lt;/h3&gt;
&lt;p&gt;If you are impatient, here are the complete codes excluding the MySQL codes and the plots. These should work after installing the required libraries shown above:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-nn', 'tabcontent-nn')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-nn', 'tabcontent-nn')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-knet-060319-nn&quot; class=&quot;tabcontent-nn first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/eda562ebbd22f3de61385ec79dad2373.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-nn&quot; class=&quot;tabcontent-nn&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/69d25cb0a6210b3e702fe582c2127ba4.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;h3 id=&quot;references-and-resources&quot;&gt;References and Resources&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MySQL.jl Github Repo: https://github.com/JuliaDatabases/MySQL.jl&lt;/li&gt;
  &lt;li&gt;PyMySQL Github Repo: https://github.com/PyMySQL/PyMySQL&lt;/li&gt;
  &lt;li&gt;Flaticon: https://www.flaticon.com/&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;software-versions&quot;&gt;Software Versions&lt;/h3&gt;
&lt;script src=&quot;https://gist.github.com/alstat/65dab0d062ea0fd229b4aa23c18fcd21.js&quot;&gt;&lt;/script&gt;</content><author><name>Al-Ahmadgaid B. Asaad</name></author><category term="julia" /><category term="python" /><summary type="html">Prior to the advent of computing, relational database can be thought of log books typically used for inventory and visitor’s time-in time-out. These books contain rows that define the item/transaction, and columns describing the features of each row. Indeed, these are the core attributes of any relational database. Unlike spreadsheets, which are used for handling small datasets, databases are mostly used for storing huge transactional data for later use. They run on a server and often at the backend of any user (client) interface such as websites and mobile applications. These applications communicate with database via processing servers (e.g. Flask and Django). The figure below illustrates the request and response communcations between client and servers. As mentioned earlier, databases are meant to store data for later use — in the sense that we can use it as a response to client’s requests, such as viewing or data extraction for insights. In this article, we are interested in data extraction from the database. In particular, the objective is to illustrate how to send request to MySQL server, and how to process response both from Julia and Python. MySQL Server Setup To start with, we need to setup MySQL server in our machine. Click the following link to download and install the application.</summary></entry><entry><title type="html">Deep Learning: Exploring High Level APIs of Knet.jl and Flux.jl in comparison to Tensorflow-Keras</title><link href="http://localhost:4000/julia/python/packages/knet/flux/tensorflow/machine-learning/deep-learning/2019/06/20/Deep-Learning-Exploring-High-Level-APIs-of-Knet.jl-and-Flux.jl-in-comparison-to-Tensorflow-Keras.html" rel="alternate" type="text/html" title="Deep Learning: Exploring High Level APIs of Knet.jl and Flux.jl in comparison to Tensorflow-Keras" /><published>2019-06-20T12:00:00+08:00</published><updated>2019-06-20T12:00:00+08:00</updated><id>http://localhost:4000/julia/python/packages/knet/flux/tensorflow/machine-learning/deep-learning/2019/06/20/Deep%20Learning:%20Exploring%20High%20Level%20APIs%20of%20Knet.jl%20and%20Flux.jl%20in%20comparison%20to%20Tensorflow-Keras</id><content type="html" xml:base="http://localhost:4000/julia/python/packages/knet/flux/tensorflow/machine-learning/deep-learning/2019/06/20/Deep-Learning-Exploring-High-Level-APIs-of-Knet.jl-and-Flux.jl-in-comparison-to-Tensorflow-Keras.html">&lt;p&gt;When it comes to complex modeling, specifically in the field of deep learning, the go-to tool for &lt;a href=&quot;https://towardsdatascience.com/which-deep-learning-framework-is-growing-fastest-3f77f14aa318&quot;&gt;most researchers&lt;/a&gt; is the &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;Google’s TensorFlow&lt;/a&gt;. There are a number of good reason as to why, one of it is the fact that it provides both high and low level APIs that suit the needs of both beginners and advanced users, respectively. I have used it in some of my projects, and indeed it was powerful enough for the task. This is also due to the fact that TensorFlow is one of the &lt;a href=&quot;https://github.com/tensorflow/tensorflow/graphs/contributors&quot;&gt;most actively&lt;/a&gt; developed deep learning framework, with Bayesian inference or probabilistic reasoning as the recent extension (see &lt;a href=&quot;https://www.tensorflow.org/probability/&quot;&gt;TensorFlow Probability&lt;/a&gt;, another extension is the &lt;a href=&quot;https://www.tensorflow.org/js&quot;&gt;TensorFlow.js&lt;/a&gt;). While the library is written majority in C++ for optimization, the main API is served in Python for ease of use. This design works around the static computational graph that needs to be defined declaratively before executed. The static nature of this graph, however, led to difficulty on debugging the models since the codes are itself data for defining the computational graph. Hence, you cannot use a debugger to check the results of the models line by line. Thankfully, it’s 2019 already and we have a stable &lt;a href=&quot;https://www.tensorflow.org/guide/eager&quot;&gt;Eager Execution&lt;/a&gt; that allows users to immediately check the results of any TensorFlow operations. Indeed, this is more intuitive and more pythonic. In this article, however, we’ll attempt to explore, what else we have in 2019. In particular, let’s take look at Julia’s deep learning libraries and compare it to high level APIs of TensorFlow, i.e. Keras’ model specification.&lt;/p&gt;

&lt;p&gt;As a language that leans towards numerical computation, it’s no surprise that Julia offers a number of choices for doing deep learning, here are the stable libraries:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://github.com/FluxML/Flux.jl&quot;&gt;Flux.jl&lt;/a&gt; - The Elegant Machine Learning Stack.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://github.com/denizyuret/Knet.jl&quot;&gt;Knet.jl&lt;/a&gt; - Koç University deep learning framework.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://github.com/alan-turing-institute/MLJ.jl&quot;&gt;MLJ.jl&lt;/a&gt; - Julia machine learning framework by Alan Turing Institute.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://github.com/apache/incubator-mxnet/tree/master/julia#mxnet&quot;&gt;MXNet.jl&lt;/a&gt; - Apache MXNet Julia package.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://github.com/malmaud/TensorFlow.jl&quot;&gt;TensorFlow.jl&lt;/a&gt; - A Julia wrapper for TensorFlow.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Other related packages are maintained in &lt;a href=&quot;https://github.com/JuliaML&quot;&gt;JuliaML&lt;/a&gt;. For this article, we are going to focus on the usage of
Flux.jl and Knet.jl, and we are going to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Iris_flower_data_set&quot;&gt;Iris dataset&lt;/a&gt; for classification task using &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilayer_perceptron&quot;&gt;Multilayer Perceptron&lt;/a&gt;. To start with, we need to install the following packages. I’m using Julia 1.1.0. and Python 3.7.3.&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-060319-1', 'tabcontent-1')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-1', 'tabcontent-1')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-060319-1&quot; class=&quot;tabcontent-1 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/0f696956e8856bbd40c4364c8bd526b8.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-1&quot; class=&quot;tabcontent-1&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/980a3dd113dea6774a8ff9c9d4b65f2b.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;h3 id=&quot;loading-and-partitioning-the-data&quot;&gt;Loading and Partitioning the Data&lt;/h3&gt;
&lt;p&gt;The Iris dataset is available in the &lt;a href=&quot;https://github.com/JuliaStats/RDatasets.jl&quot;&gt;RDatasets.jl&lt;/a&gt; Julia package and in Python’s &lt;a href=&quot;https://scikit-learn.org/&quot;&gt;Scikit-Learn&lt;/a&gt;. The following codes load the libraries and the data itself.&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-060319-knet-2', 'tabcontent-2')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-060319-flux-2', 'tabcontent-2')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-2', 'tabcontent-2')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-060319-knet-2&quot; class=&quot;tabcontent-2 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/e8dcf372308bf96df39b098a4b443d33.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-060319-flux-2&quot; class=&quot;tabcontent-2&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/d8bee345413942db404ab30609c91170.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-2&quot; class=&quot;tabcontent-2&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/9e763b0ddbe0e010da6191322b79a394.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;The random seed set above is meant for reproducibility as it will give us the same random initial values for model training. The &lt;code&gt;iris&lt;/code&gt; variable in line 11 (referring to Julia code) contains the data, and is a data frame with 150 × 5 dimensions, where the columns are: Sepal Length, Sepal Width, Petal Length, Petal Width, and Species. There are several ways to partition this data into training and testing datasets, one procedure is to do stratified sampling, with simple random sampling without replacement as the sampling selection within each stratum — the species. The following codes define the function for partitioning the data with the mentioned sampling design:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-060319-3', 'tabcontent-3')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-3', 'tabcontent-3')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-060319-3&quot; class=&quot;tabcontent-3 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/f1441c844ef4a5f465b00f60aa11ec85.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-3&quot; class=&quot;tabcontent-3&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/ef9c6e6fdd78dd4931458e1c7a644644.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;Extract the training and testing datasets using the function above as follows:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-4', 'tabcontent-4')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-flux-060319-4', 'tabcontent-4')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-4', 'tabcontent-4')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-knet-060319-4&quot; class=&quot;tabcontent-4 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/b49d14f563a43b2e2d25b1b70860539c.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-flux-060319-4&quot; class=&quot;tabcontent-4 first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/54a248104146c7e94340510b0a1c26eb.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-4&quot; class=&quot;tabcontent-4&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/9c5c3549794b0918172205235137ad25.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;All three codes above extract &lt;code&gt;xtrn&lt;/code&gt;, the training data (feature) matrix of size 105 × 4 (105 observations by 4 features) dimensions; &lt;code&gt;ytrn&lt;/code&gt;, the corresponding training target variable with 105 × 1 dimension; &lt;code&gt;xtst&lt;/code&gt;, the feature matrix for testing dataset with 45 × 4 dimensions; and &lt;code&gt;ytst&lt;/code&gt;, the target variable with 45 × 1 dimension for testing dataset. Moreover, contrary to TensorFlow-Keras, Knet.jl and Flux.jl need further data preparation from the above partitions. In particular, Knet.jl takes minibatch object as input data for model training, while Flux.jl needs one-hot encoding for the target variables &lt;code&gt;ytrn&lt;/code&gt; and &lt;code&gt;ytst&lt;/code&gt;. Further, unlike Knet.jl which ships with minibatch function, Flux.jl gives the user the flexibility to create their own.&lt;/p&gt;

&lt;h3 id=&quot;specify-the-model&quot;&gt;Specify the Model&lt;/h3&gt;
&lt;p&gt;The model that we are going to use is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilayer_perceptron&quot;&gt;Multilayer Perceptron&lt;/a&gt; with the following architecture: 4 neurons for the input layer, 10 neurons for the hidden layer, and 3 neurons for the output layer.  The first two layers contain bias, and the neurons of the last two layers are activated with Rectified Linear Unit (ReLU) and softmax functions, respectively.  The diagram below illustrates the architecture described:
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1oYnD8KZ1NQqbJccw8NYugj0kqihQZBJX&quot; /&gt;
&lt;!-- https://drive.google.com/file/d/1jqASeBjmbSImp5hEoEZxHMizKUkSLyC8/view?usp=sharing --&gt;
The codes below specify the model:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-5', 'tabcontent-5')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-flux-060319-5', 'tabcontent-5')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-5', 'tabcontent-5')&quot;&gt;Python (TensorFlow-Keras)&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-knet-060319-5&quot; class=&quot;tabcontent-5 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/e5ebdd980786a552511ceafcc70905f5.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-flux-060319-5&quot; class=&quot;tabcontent-5 first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/b84fe0bc6c5bfba22d903f1bc8b1f774.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-5&quot; class=&quot;tabcontent-5 first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/b99baeaf255f8704e64a0ff9077e0283.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;Coming from TensorFlow-Keras, Flux.jl provides Keras-like API for model specification, with &lt;code&gt;Flux.Chain&lt;/code&gt; as the counterpart for Keras’ &lt;code&gt;Sequential&lt;/code&gt;. This is different from Knet.jl where the highest level API you can get are the nuts and bolts for constructing the layers. Having said, however, &lt;code&gt;Flux.Dense&lt;/code&gt; is defined almost exactly as the Dense struct of the Knet.jl code above (check the source code &lt;a href=&quot;https://github.com/FluxML/Flux.jl/blob/1902c0e7c568a1bdb0cda7dca4d69f3896c023c7/src/layers/basic.jl#L82-L100&quot;&gt;here&lt;/a&gt;). In addition, since both Flux.jl and Knet.jl are written purely in Julia, makes the source codes under the hood accessible to beginners. Thus, giving the user a full understanding of not just the code, but also the math. Check the screenshots below for the distribution of the file types in the Github repos of the three frameworks:
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1hmWiYy6C01q_X8HGl5xDSjQClJz5H7Ym&quot; /&gt;
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=17VAf7wOT9Ej47OZQu9B6o4kOCCs4G_tw&quot; /&gt;
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=18RmeurpIX0uzBP9sKwiN24QI_VVLicYF&quot; /&gt;
From the above figure, it’s clear that Flux.jl is 100% Julia. On the other hand, Knet.jl while not apparent is actually 100% Julia as well. The 41.4% of Jupyter Notebooks and other small percentages account for the tutorials, tests and examples and not the &lt;a href=&quot;https://github.com/denizyuret/Knet.jl/tree/master/src&quot;&gt;source codes&lt;/a&gt;.
&lt;!-- There are several --&gt;
&lt;!-- &lt;img src=&quot;http://drive.google.com/uc?export=view&amp;id=1HKlC04oVF_3ggraWE7qnMNvW-Atxc89N&quot;&gt; --&gt;
&lt;!-- https://drive.google.com/file/d/1HKlC04oVF_3ggraWE7qnMNvW-Atxc89N/view?usp=sharing --&gt;&lt;/p&gt;
&lt;h3 id=&quot;train-the-model&quot;&gt;Train the Model&lt;/h3&gt;
&lt;p&gt;Finally, train the model as follows for 100 epochs:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-6', 'tabcontent-6')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-flux-060319-6', 'tabcontent-6')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-6', 'tabcontent-6')&quot;&gt;Python (TensorFlow-Keras)&lt;/button&gt;
&lt;/div&gt;
&lt;div id=&quot;julia-knet-060319-6&quot; class=&quot;tabcontent-6 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/e06a44c5d748f2e0d266f0882b623b2a.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-flux-060319-6&quot; class=&quot;tabcontent-6 first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/c007ed68a89d4974419ad4ffcea2ff81.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-6&quot; class=&quot;tabcontent-6&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/82525c52d17b5a5b470c392598a99e58.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;The codes (referring to Julia codes) above save both loss and accuracy for every epoch into a data frame and then into a CSV file. These will be used for visualization. Moreover, unlike Flux.jl and Knet.jl which require minibatch preparation prior to training, TensorFlow-Keras specifies this on &lt;code&gt;fit&lt;/code&gt; method as shown above. Further, it is also possible to train the model in Knet.jl using a single function without saving the metrics. This is done as follows:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-6-a', 'tabcontent-6-a')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-flux-060319-6-a', 'tabcontent-6-a')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
&lt;/div&gt;
&lt;div id=&quot;julia-knet-060319-6-a&quot; class=&quot;tabcontent-6-a first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/cc3882f36e47ef8c289392626131af9d.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-flux-060319-6-a&quot; class=&quot;tabcontent-6-a first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/5002d261a67eccebd174ad0ea43969e4.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;The Flux.jl code above simply illustrates the use of &lt;code&gt;Flux.@epochs&lt;/code&gt; macro for looping instead of the &lt;code&gt;for&lt;/code&gt; loop. The loss of the model for 100 epochs is visualized below across frameworks:
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=11y4RGyrY1e62cNl9H6Kce6tdcVug8AHt&quot; /&gt;
From the above figure, one can observe that Flux.jl had a bad starting values set by the random seed earlier, good thing &lt;a href=&quot;https://arxiv.org/abs/1412.6980&quot;&gt;Adam&lt;/a&gt; drives the gradient vector rapidly to the global minimum. The figure was plotted using &lt;a href=&quot;http://gadflyjl.org/stable/index.html&quot;&gt;Gadfly.jl&lt;/a&gt;. Install this package using &lt;code&gt;Pkg&lt;/code&gt; as described in the first code block, along with &lt;a href=&quot;https://github.com/JuliaGraphics/Cairo.jl&quot;&gt;Cario.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGraphics/Fontconfig.jl&quot;&gt;Fontconfig.jl&lt;/a&gt;. The latter two packages are used to save the plot in PNG format, see the code below to reproduce:
&lt;script src=&quot;https://gist.github.com/alstat/f0d63cf8cd0b41125f9bc072e0fc451b.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;evaluate-the-model&quot;&gt;Evaluate the Model&lt;/h3&gt;
&lt;p&gt;The output of the model ends with a vector of three neurons. The index or location of the neurons in this vector defines the corresponding integer encoding, with 1st index as setosa, 2nd as versicolor, and 3rd as virginica. Thus, the codes below take the argmax of the vector to get the integer encoding for evaluation.&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-7', 'tabcontent-7')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-flux-060319-7', 'tabcontent-7')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-7', 'tabcontent-7')&quot;&gt;Python (TensorFlow-Keras)&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-knet-060319-7&quot; class=&quot;tabcontent-7 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/668465ba90240dc071a71c8132f07268.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-flux-060319-7&quot; class=&quot;tabcontent-7 first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/59a20104dcdce45045e28a5d60ffd86d.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-7&quot; class=&quot;tabcontent-7&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/59d17503d149abbe4ec338b4190affec.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;The figure below shows the traces of the accuracy during training:
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1L2d8mfkC-9zl3KeLXdVpynXR_OuyyzC1&quot; /&gt;
TensorFlow took 25 epochs before surpassing 50% again. To reproduce the figure, run the following codes (make sure to load Gadfly.jl and other related libraries mentioned earlier in generating the loss plots):
&lt;script src=&quot;https://gist.github.com/alstat/9539e00aef208062b1c6b900efa6c258.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;benchmark&quot;&gt;Benchmark&lt;/h3&gt;
&lt;p&gt;At this point, we are going to record the training time of each framework.&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-8', 'tabcontent-8')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-flux-060319-8', 'tabcontent-8')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-8', 'tabcontent-8')&quot;&gt;Python (TensorFlow-Keras)&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-knet-060319-8&quot; class=&quot;tabcontent-8 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/0381d47e59cc9dd401fc9fb1342f2374.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-flux-060319-8&quot; class=&quot;tabcontent-8 first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/d738aeeaa2cddb62ee41478748d4446b.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-8&quot; class=&quot;tabcontent-8&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/cf2bf0fac9fe9e55051f524d353aaf97.js&quot;&gt;&lt;/script&gt;  
&lt;/div&gt;
&lt;p&gt;The benchmark was done by running the above code repeatedly for about 10 times for each framework, I then took the lowest timestamp out of the results. In addition, before running the code for each framework, I keep a fresh start of my machine.
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1u0selT5l8vP7n-LNdvac_bzyMGC1vSDD&quot; /&gt;
The code of the above figure is given below (make sure to load Gadfly.jl and other related libraries mentioned earlier in generating the loss plots):
&lt;script src=&quot;https://gist.github.com/alstat/c1bc13ab6e772a4104b51d164f4e172d.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In conclusion, I would say Julia is worth investing even for deep learning as illustrated in this article. The two frameworks, Flux.jl and Knet.jl, provide a clean API that introduces a new way of defining models, as opposed to the object-oriented approach of the TensorFlow-Keras. One thing to emphasize on this is the &lt;code&gt;for&lt;/code&gt; loop which I plainly added in training the model just to save the accuracy and loss metrics. The &lt;code&gt;for&lt;/code&gt; loop did not compromise the speed (though Knet.jl is much faster without it). This is crucial since it let’s the user spend more on solving the problem and less on optimizing the code. Further, between the two Julia frameworks, I find Knet.jl to be &lt;a href=&quot;https://www.youtube.com/watch?v=ijI0BLf-AH0&quot;&gt;Julia + little-else&lt;/a&gt;, as described by &lt;a href=&quot;http://www.denizyuret.com/&quot;&gt;Professor Deniz Yuret&lt;/a&gt; (the main developer), since there are no special APIs for Dense, Chains, etc., you have to code it. Although this is also possible for Flux.jl, but Knet.jl don’t have these out-of-the-box, it ships only with the nuts and bolts, and that’s the highest level APIs the user gets. Having said, I think Flux.jl is a better recommendation for beginners coming from TensorFlow-Keras. This is not to say that Knet.jl is hard, it’s not if you know Julia already. In addition, I do love the extent of flexibility on Knet.jl by default which I think is best for advanced users. Lastly, just like the different extensions of TensorFlow, Flux.jl is flexible enough that it works well with &lt;a href=&quot;https://turing.ml/&quot;&gt;Turing.jl&lt;/a&gt; for doing Bayesian deep learning, which is a good alternative for &lt;a href=&quot;https://www.tensorflow.org/probability/&quot;&gt;TensorFlow Probability&lt;/a&gt;. For Neural Differential Equations, Flux.jl works well with &lt;a href=&quot;https://github.com/JuliaDiffEq/DifferentialEquations.jl&quot;&gt;DifferentialEquations.jl&lt;/a&gt;, checkout &lt;a href=&quot;https://julialang.org/blog/2019/01/fluxdiffeq&quot;&gt;DiffEqFlux.jl&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h3&gt;
&lt;p&gt;In my next article, we will explore the low level APIs of Flux.jl and Knet.jl in comparison to the low level APIs of TensorFlow. One thing that’s missing also from the above exercise is the use of GPU for model training, and I hope to tackle this in future articles. Finally, I plan to test these Julia libraries on real deep learning problems, such as computer vision and natural language processing (checkout the &lt;a href=&quot;https://www.youtube.com/watch?v=21_wokgnNog&quot;&gt;workshop&lt;/a&gt; on these from JuliaCon 2018).&lt;/p&gt;
&lt;h3 id=&quot;complete-codes&quot;&gt;Complete Codes&lt;/h3&gt;
&lt;p&gt;If you are impatient, here are the complete codes excluding the benchmarks and the plots. These should work after installing the required libraries shown above:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-knet-060319-n', 'tabcontent-n')&quot;&gt;Julia (Knet.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-flux-060319-n', 'tabcontent-n')&quot;&gt;Julia (Flux.jl)&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-060319-n', 'tabcontent-n')&quot;&gt;Python (TensorFlow-Keras)&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-knet-060319-n&quot; class=&quot;tabcontent-n first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/e51343935f90c972aa6dcf18b60aefe2.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-flux-060319-n&quot; class=&quot;tabcontent-n first&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/004cc6d457bd22fce99148d14f37dc32.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-060319-n&quot; class=&quot;tabcontent-n&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/1bdf9cc7019ca0e5684c991fae4715ec.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Yuret, Deniz (2016). &lt;a href=&quot;https://pdfs.semanticscholar.org/28ee/845420b8ba275cf1d695fbf383cc21922fbd.pdf&quot;&gt;Knet: beginning deep learning with 100 lines of Julia&lt;/a&gt;. 30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.&lt;/li&gt;
  &lt;li&gt;Innes, Mike (2018). &lt;a href=&quot;http://joss.theoj.org/papers/10.21105/joss.00602&quot;&gt;Flux: Elegant machine learning with Julia&lt;/a&gt;. Journal of Open Source Software, 3(25), 602, https://doi.org/10.21105/joss.00602&lt;/li&gt;
  &lt;li&gt;Abadi, Martin et al (2016). &lt;a href=&quot;https://www.usenix.org/system/files/conference/osdi16/osdi16-abadi.pdf&quot;&gt;TensorFlow-Keras: A system for large-scale machine learning&lt;/a&gt;. 12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16). p265–283.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;software-versions&quot;&gt;Software Versions&lt;/h3&gt;
&lt;script src=&quot;https://gist.github.com/alstat/65dab0d062ea0fd229b4aa23c18fcd21.js&quot;&gt;&lt;/script&gt;</content><author><name>Al-Ahmadgaid B. Asaad</name></author><category term="julia" /><category term="python" /><summary type="html">When it comes to complex modeling, specifically in the field of deep learning, the go-to tool for most researchers is the Google’s TensorFlow. There are a number of good reason as to why, one of it is the fact that it provides both high and low level APIs that suit the needs of both beginners and advanced users, respectively. I have used it in some of my projects, and indeed it was powerful enough for the task. This is also due to the fact that TensorFlow is one of the most actively developed deep learning framework, with Bayesian inference or probabilistic reasoning as the recent extension (see TensorFlow Probability, another extension is the TensorFlow.js). While the library is written majority in C++ for optimization, the main API is served in Python for ease of use. This design works around the static computational graph that needs to be defined declaratively before executed. The static nature of this graph, however, led to difficulty on debugging the models since the codes are itself data for defining the computational graph. Hence, you cannot use a debugger to check the results of the models line by line. Thankfully, it’s 2019 already and we have a stable Eager Execution that allows users to immediately check the results of any TensorFlow operations. Indeed, this is more intuitive and more pythonic. In this article, however, we’ll attempt to explore, what else we have in 2019. In particular, let’s take look at Julia’s deep learning libraries and compare it to high level APIs of TensorFlow, i.e. Keras’ model specification.</summary></entry><entry><title type="html">Julia: Introduction to Web Scraping (PHIVOLCS’ Seismic Events)</title><link href="http://localhost:4000/web/scraping/philippines/julia/programming/packages/2018/10/30/Introduction-to-Web-Scraping-Julia.html" rel="alternate" type="text/html" title="Julia: Introduction to Web Scraping (PHIVOLCS' Seismic Events)" /><published>2018-10-30T12:00:00+08:00</published><updated>2018-10-30T12:00:00+08:00</updated><id>http://localhost:4000/web/scraping/philippines/julia/programming/packages/2018/10/30/Introduction-to-Web-Scraping-Julia</id><content type="html" xml:base="http://localhost:4000/web/scraping/philippines/julia/programming/packages/2018/10/30/Introduction-to-Web-Scraping-Julia.html">&lt;p&gt;Data nowadays are almost everywhere, often stored in as simple as traditional log books, to as complex as multi-connected-databases. Efficient collection of these datasets is crucial for analytics since data processing takes almost 50% of the overall workflow. An example where manual data collection can be automated is in the case of datasets published in the website, where providers are usually government agencies. For example in the Philippines, there is a website dedicated to &lt;a href=&quot;http://openstat.psa.gov.ph/&quot; target=&quot;_blank&quot;&gt;Open Stat&lt;/a&gt; initiated by the &lt;a href=&quot;https://psa.gov.ph/&quot; target=&quot;_blank&quot;&gt;Philippine Statistics Authority (PSA)&lt;/a&gt;. The site hoards public datasets for researchers to use and are well prepared in CSV format, so consumers can simply download the file. Unfortunately, for some agencies this feature is not yet available. That is, users need to either copy-paste the data from the website, or request it to the agency directly (this also takes time). A good example of this is the seismic events of the &lt;a href=&quot;https://www.phivolcs.dost.gov.ph/&quot; target=&quot;_blank&quot;&gt;Philippine Institute of Volcanology and Seismology (PHIVOLCS)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Data encoded in HTML can be parsed and saved into formats that’s workable for doing analyses (e.g. CSV, TSV, etc.). The task of harvesting and parsing data from the web is called &lt;strong&gt;web scraping&lt;/strong&gt;, and PHIVOLCS’ &lt;a href=&quot;https://www.phivolcs.dost.gov.ph/html/update_SOEPD/EQLatest.html&quot; target=&quot;_blank&quot;&gt;Latest Seismic Events&lt;/a&gt; is a good playground for beginners. There are several tutorials available especially for Python (see &lt;a href=&quot;https://www.dataquest.io/blog/web-scraping-tutorial-python/&quot; target=&quot;_blank&quot;&gt;this&lt;/a&gt;) and R (see &lt;a href=&quot;https://www.analyticsvidhya.com/blog/2017/03/beginners-guide-on-web-scraping-in-r-using-rvest-with-hands-on-knowledge/&quot; target=&quot;_blank&quot;&gt;this&lt;/a&gt;), but not much for Julia. Hence, this article is primarily for Julia users. However, this work introduces web tools as well – how to use it for inspecting the components of the website – which can be useful for non-Julia users.&lt;/p&gt;

&lt;h3 id=&quot;why-julia&quot;&gt;Why Julia?&lt;/h3&gt;
&lt;p&gt;The creators of the language described it well in their first announcement (I suggest you read the full post): &lt;a href=&quot;https://julialang.org/blog/2012/02/why-we-created-julia&quot; target=&quot;_blank&quot;&gt;Why we created Julia?&lt;/a&gt; Here’s part of it:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;We are greedy: we want more.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;We want a language that’s open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that’s homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;(Did we mention it should be as fast as C?)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I used Julia in my master’s thesis for my &lt;a href=&quot;https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo&quot; target=&quot;_blank&quot;&gt;MCMC simulations&lt;/a&gt; and benchmarked it against R. It took seconds in Julia while R took more than an hour (sampling over the posterior distribution). I could have optimized my R code using &lt;a href=&quot;http://www.rcpp.org/&quot; target=&quot;_blank&quot;&gt;Rcpp&lt;/a&gt; (writting the performance-critical part in C++ to speed up and wrapped/call it in R), but I have no time for that. Hence, Julia solves the &lt;a href=&quot;https://www.quora.com/What-is-the-2-language-problem-in-data-science&quot; target=&quot;_blank&quot;&gt;two-language problem&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;getting-to-know-html&quot;&gt;Getting to know HTML&lt;/h3&gt;
&lt;p&gt;Since the data published in the websites are usually encoded as a table, it is therefore best to understand the structure of the HTML document before performing web scraping. HTML (Hypertext Markup Language) is a standardized system for tagging text files to achieve font, color, graphic, and hyperlink effects on World Wide Web pages [&lt;a href=&quot;https://www.google.com/search?q=what+is+HTML&amp;amp;ie=utf-8&amp;amp;oe=utf-8&amp;amp;client=firefox-b-ab&quot; target=&quot;_blank&quot;&gt;1&lt;/a&gt;]. For example, bold text in HTML is enclosed inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tag, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;&lt;/code&gt;text&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;, the result is &lt;b&gt;text&lt;/b&gt;. A webpage is a HTML document that can be structured in several ways, one possible case is as follows:
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1WW3yUzJ5ZhGRNPYolM_S4dsJ5ts5urPU&quot; /&gt;
Scrapers must be familiar with the hierarchy of the HTML document as this will be the template for the frontend source code of every website. Following the structure of the above figure, data encoded in HTML table are placed inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt; (table data) tag, where &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt; is under &lt;code class=&quot;highlighter-rouge&quot;&gt;tr&lt;/code&gt; (table row), &lt;code class=&quot;highlighter-rouge&quot;&gt;tr&lt;/code&gt; is under &lt;code class=&quot;highlighter-rouge&quot;&gt;tbody&lt;/code&gt; (table body), and so on. &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt; is the lowest level tag (sorting by hierarchy) from the figure above that can contain data. However, &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt; can also take precedence over &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; (paragraph), &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; (hyperlink), &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; (bold), &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; (italic), &lt;code class=&quot;highlighter-rouge&quot;&gt;span&lt;/code&gt; (span), and even &lt;code class=&quot;highlighter-rouge&quot;&gt;div&lt;/code&gt; (division). So expect to encounter these under &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;As indicated in the figure, each HTML tag can have attributes, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;. To understand how the two differ, consider &lt;code class=&quot;highlighter-rouge&quot;&gt;id=&quot;yellow&quot;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;id=&quot;orange&quot;&lt;/code&gt;, these are unique identities (&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;s) of colors. These &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;s can be grouped into a class, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;class=&quot;colors&quot;&lt;/code&gt;. HTML tags are not required to have these attributes but are useful for adding custom styles and behavior when doing web development. This article will not dive into the details of the HTML document, but rather to give the reader a high level understanding. There are many resources available on the web, just google.&lt;/p&gt;
&lt;h3 id=&quot;inspecting-the-source-of-the-website&quot;&gt;Inspecting the Source of the Website&lt;/h3&gt;
&lt;p&gt;In order to have an idea on the structure of the website, browsers such as Google Chrome and Mozilla Firefox include tools for Web Developers. For purpose of illustration but without loss of generality, this article will only scrape portion (why? read on and see the explanation below) of the &lt;a href=&quot;https://www.phivolcs.dost.gov.ph/html/update_SOEPD/EQLatest-Monthly/2018/2018_September.html&quot; target=&quot;_blank&quot;&gt;September 2018 earthquake events&lt;/a&gt;. The web developer tools can be accessed from &lt;b&gt;Tools &amp;gt; Web Developer&lt;/b&gt; in Firefox, and can be accessed from &lt;b&gt;View &amp;gt; Developer&lt;/b&gt; in Google Chrome. The following video shows how to use the inspector tool of the Mozilla Firefox.&lt;/p&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;400px&quot; src=&quot;https://www.youtube.com/embed/RJEnugditnA&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;scraping-using-julia&quot;&gt;Scraping using Julia&lt;/h3&gt;
&lt;p&gt;To perform web scraping, Julia offers three libraries for the job, and these are &lt;a href=&quot;https://github.com/Algocircle/Cascadia.jl&quot; target=&quot;_blank&quot;&gt;Cascadia.jl&lt;/a&gt;, &lt;a href=&quot;https://github.com/JuliaWeb/Gumbo.jl&quot; target=&quot;_blank&quot;&gt;Gumbo.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaWeb/HTTP.jl&quot; target=&quot;_blank&quot;&gt;HTTP.jl&lt;/a&gt;. &lt;a href=&quot;https://github.com/JuliaWeb/HTTP.jl&quot; target=&quot;_blank&quot;&gt;HTTP.jl&lt;/a&gt; is used to download the frontend source code of the website, which then is parsed by &lt;a href=&quot;https://github.com/JuliaWeb/Gumbo.jl&quot; target=&quot;_blank&quot;&gt;Gumbo.jl&lt;/a&gt; into a hierarchical structured object; and &lt;a href=&quot;https://github.com/Algocircle/Cascadia.jl&quot; target=&quot;_blank&quot;&gt;Cascadia.jl&lt;/a&gt; provides a CSS selector API for easy navigation.&lt;/p&gt;

&lt;p&gt;To start with, the following code will download the frontend source code of the PHIVOLCS’ Seismic Events for September 2018. 
&lt;script src=&quot;https://gist.github.com/alstat/4e5bbbb9587b6506c4341a8097804c69.js&quot;&gt;&lt;/script&gt;
Extract the HTML source code and parsed it as follows:
&lt;script src=&quot;https://gist.github.com/alstat/deb9ef2abe52af58fc03be63f0482ccf.js&quot;&gt;&lt;/script&gt;
Now to extract the header of the HTML table, use the Web Developer Tools for preliminary inspection on the components of the website. As shown in the screenshot below, the header of the table is enclosed inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; tag of the &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt;. Further, the &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; tag is of class &lt;code class=&quot;highlighter-rouge&quot;&gt;auto-style33&lt;/code&gt;, which can be accessed via CSS selector by simply prefixing it with &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;.auto-style33&lt;/code&gt;.
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1LVNFZRHdT-o-vX-0dLiBMiVv3872LXpE&quot; /&gt;
&lt;script src=&quot;https://gist.github.com/alstat/63c8855a48c9a33669c9bdd4d3ae2e9a.js&quot;&gt;&lt;/script&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;qres&lt;/code&gt; contains the HTML tags that matched the CSS selector’s query. The result is further cleaned by removing the tabs, spaces and line breaks via &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot; target=&quot;_blank&quot;&gt;Regular Expressions&lt;/a&gt;, and is done as follows:
&lt;script src=&quot;https://gist.github.com/alstat/94e5af21b303b995d93af24a8ae69841.js&quot;&gt;&lt;/script&gt;
Having the header names, next is to extract the data from the HTML table. Upon inspection, the &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt;s containing the data next to the header rows seem to have the following classes (see screenshot below): &lt;code class=&quot;highlighter-rouge&quot;&gt;auto-style21&lt;/code&gt; for first column (Date-Time), &lt;code class=&quot;highlighter-rouge&quot;&gt;auto-style81&lt;/code&gt; for second column (Latitude), &lt;code class=&quot;highlighter-rouge&quot;&gt;auto-style80&lt;/code&gt; for third and fourth columns (Longitude and Depth), &lt;code class=&quot;highlighter-rouge&quot;&gt;auto-style74&lt;/code&gt; for fifth column (Magnitude), and &lt;code class=&quot;highlighter-rouge&quot;&gt;auto-style79&lt;/code&gt; for sixth column (Location). Unfortunately, this is not consistent across rows (&lt;code class=&quot;highlighter-rouge&quot;&gt;tr&lt;/code&gt;s), and is therefore best not to use it with &lt;a href=&quot;https://github.com/Algocircle/Cascadia.jl&quot; target=&quot;_blank&quot;&gt;Cascadia.jl&lt;/a&gt;. Instead, use &lt;a href=&quot;https://github.com/JuliaWeb/Gumbo.jl&quot; target=&quot;_blank&quot;&gt;Gumbo.jl&lt;/a&gt; to navigate down the hierarchy of the &lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;Document Object Model&lt;/a&gt; of the HTML.
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1XEkudOAB7o4Cix5CY4tqSJe2J0BpoJ_G&quot; /&gt;
Starting with the &lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt; tag which is of class &lt;code class=&quot;highlighter-rouge&quot;&gt;.MsoNormalTable&lt;/code&gt; (see screenshot below), the extraction proceeds down to &lt;code class=&quot;highlighter-rouge&quot;&gt;tbody&lt;/code&gt; then to &lt;code class=&quot;highlighter-rouge&quot;&gt;tr&lt;/code&gt; and finally to &lt;code class=&quot;highlighter-rouge&quot;&gt;td&lt;/code&gt;.
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1x3N58LE_5ENyzMbyyhrx8Zrlgp40EBNI&quot; /&gt;
The following code describes how parsing is done, read the comments:
&lt;script src=&quot;https://gist.github.com/alstat/b4fbfe5dc8330ef16ad1abc05d44056f.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;complete-code-for-phivolcs-september-2018-portion-seismic-events&quot;&gt;Complete Code for PHIVOLCS’ September 2018 (Portion) Seismic Events&lt;/h3&gt;
&lt;p&gt;The September 2018 Seismic Events are encoded in two separate HTML tables of the same class, named &lt;code class=&quot;highlighter-rouge&quot;&gt;MsoNormalTable&lt;/code&gt;. For purpose of simplicity, this article will only scrape the first portion (3rd-indexed, see line 14 below: &lt;code class=&quot;highlighter-rouge&quot;&gt;tbody = html[3][1];&lt;/code&gt;) of the table (581 rows). The second portion (4th-indexed, change line 14 below to: &lt;code class=&quot;highlighter-rouge&quot;&gt;tbody = html[4][1];&lt;/code&gt;) is left to the reader to try out and scrape it as well.&lt;/p&gt;

&lt;p&gt;The following code wraps the parsers into functions, namely &lt;code class=&quot;highlighter-rouge&quot;&gt;htmldoc&lt;/code&gt; (downloads and parses the HTML source code of the site), &lt;code class=&quot;highlighter-rouge&quot;&gt;scraper&lt;/code&gt; (scrapes the downloaded HTML document), &lt;code class=&quot;highlighter-rouge&quot;&gt;firstcolumn&lt;/code&gt; (logic for parsing the first column of the table, used inside &lt;code class=&quot;highlighter-rouge&quot;&gt;scraper&lt;/code&gt; function).
&lt;script src=&quot;https://gist.github.com/alstat/698125867d853b941ab4284de34d9362.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://gist.github.com/alstat/5b7463964703db410b05214f124bf028.js&quot;&gt;&lt;/script&gt;
Having the data, analyst can now proceed to do exploratory analyses, for example the following is the descriptive statistics of the variables:
&lt;script src=&quot;https://gist.github.com/alstat/8e7506524552f00bf8d8cdb690bda27b.js&quot;&gt;&lt;/script&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;describe&lt;/code&gt; is clever enough not only to not return &lt;code class=&quot;highlighter-rouge&quot;&gt;mean&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;median&lt;/code&gt; for non-continuous variables, but also determine the &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;max&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;nunique&lt;/code&gt; (number of uniques) for these variables (date and location).&lt;/p&gt;
&lt;h3 id=&quot;end-note&quot;&gt;End Note&lt;/h3&gt;
&lt;p&gt;I use Python primarily at work with &lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/&quot; target=&quot;_blank&quot;&gt;BeautifulSoup&lt;/a&gt; as my go-to library for web scraping. Compared to &lt;a href=&quot;https://github.com/Algocircle/Cascadia.jl&quot; target=&quot;_blank&quot;&gt;Cascadia.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaWeb/Gumbo.jl&quot; target=&quot;_blank&quot;&gt;Gumbo.jl&lt;/a&gt;, &lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/&quot; target=&quot;_blank&quot;&gt;BeautifulSoup&lt;/a&gt; offers comprehensive documentations and other resources that are useful for figuring out bugs, and understand how the module works. Having said, I hope this article somehow contributed to the documentation of the said Julia libraries. Further, I am confident to say that &lt;a href=&quot;https://github.com/Algocircle/Cascadia.jl&quot; target=&quot;_blank&quot;&gt;Cascadia.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaWeb/Gumbo.jl&quot; target=&quot;_blank&quot;&gt;Gumbo.jl&lt;/a&gt; are stable enough for the job.&lt;/p&gt;

&lt;p&gt;Lastly, as a precaution to beginners, make sure to read the privacy policy (if any) of any website you want to scrape.&lt;/p&gt;

&lt;h3 id=&quot;software-versions&quot;&gt;Software Versions&lt;/h3&gt;
&lt;script src=&quot;https://gist.github.com/alstat/12f52ef5b2c76fdeb5f927fc3239c613.js&quot;&gt;&lt;/script&gt;</content><author><name>Al-Ahmadgaid B. Asaad</name></author><category term="julia" /><summary type="html">Data nowadays are almost everywhere, often stored in as simple as traditional log books, to as complex as multi-connected-databases. Efficient collection of these datasets is crucial for analytics since data processing takes almost 50% of the overall workflow. An example where manual data collection can be automated is in the case of datasets published in the website, where providers are usually government agencies. For example in the Philippines, there is a website dedicated to Open Stat initiated by the Philippine Statistics Authority (PSA). The site hoards public datasets for researchers to use and are well prepared in CSV format, so consumers can simply download the file. Unfortunately, for some agencies this feature is not yet available. That is, users need to either copy-paste the data from the website, or request it to the agency directly (this also takes time). A good example of this is the seismic events of the Philippine Institute of Volcanology and Seismology (PHIVOLCS).</summary></entry><entry><title type="html">Julia, Python, R: Introduction to Bayesian Linear Regression</title><link href="http://localhost:4000/data/analyses/wrangling/julia/programming/packages/2018/10/14/Introduction-to-Bayesian-Linear-Regression.html" rel="alternate" type="text/html" title="Julia, Python, R: Introduction to Bayesian Linear Regression" /><published>2018-10-14T12:00:00+08:00</published><updated>2018-10-14T12:00:00+08:00</updated><id>http://localhost:4000/data/analyses/wrangling/julia/programming/packages/2018/10/14/Introduction-to-Bayesian-Linear-Regression</id><content type="html" xml:base="http://localhost:4000/data/analyses/wrangling/julia/programming/packages/2018/10/14/Introduction-to-Bayesian-Linear-Regression.html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Thomas_Bayes&quot; target=&quot;_blank&quot;&gt;Reverend Thomas Bayes&lt;/a&gt; (see Bayes, 1763) is known to be the first to formulate the Bayes’ theorem, but the comprehensive mathematical formulation of this result is credited to the works of &lt;a href=&quot;https://en.wikipedia.org/wiki/Pierre-Simon_Laplace&quot; target=&quot;_blank&quot;&gt;Laplace&lt;/a&gt; (1986). The Bayes’ theorem has the following form:&lt;/p&gt;
&lt;div class=&quot;math&quot;&gt;
\begin{equation}
\label{eq:bayes-theorem}
\mathbb{P}(\mathbf{w}|\mathbf{y}) = \frac{\mathbb{P}(\mathbf{w})\mathbb{P}(\mathbf{y}|\mathbf{w})}{\mathbb{P}(\mathbf{y})}
\end{equation}
&lt;/div&gt;
&lt;p&gt;where $\mathbf{w}$ is the weight vector and $\mathbf{y}$ is the data. This simple formula is the main foundation of Bayesian modeling. Any model estimated using Maximum Likelihood can be estimated using the above conditional probability. What makes it different, is that the Bayes’ theorem considers uncertainty not only on the observations but also uncertainty on the weights or the objective parameters.&lt;/p&gt;

&lt;p&gt;As an illustration of Bayesian inference to basic modeling, this article attempts to discuss the Bayesian approach to linear regression. Let ${\mathscr{D}={(\mathbf{x}_1,y_1),\cdots,(\mathbf{x}_n,y_n)}}$ where $\mathbf{x}_i\in\mathbb{R}^{d}, y_i\in \mathbb{R}$ be the pairwised dataset. Suppose the response values, $y_1,\cdots,y_n$, are independent given the parameter $\mathbf{w}$, and is distributed as $y_i\sim\mathcal{N}(\mathbf{w}^{\text{T}}\mathbf{x}_i,\alpha^{-1})$, where $\alpha^{-1}$ (assumed to be known in this article) is referred to as the &lt;i&gt;precision&lt;/i&gt; parameter — useful for later derivation. In Bayesian perspective, the weights are assumed to be random and are governed by some &lt;i&gt;a priori&lt;/i&gt; distribution. The choice of this distribution is subjective, but choosing arbitrary &lt;i&gt;a priori&lt;/i&gt; can sometimes or often result to an intractable integration, especially for interesting models. For simplicity, a conjugate prior is used for the latent weights. Specifically, assume that ${\mathbf{w}\sim\mathcal{N}(\mathbf{0},\beta^{-1}\mathbf{I})}$ such that $\beta&amp;gt;0$ is the hyperparameter supposed in this experiment as known value. The posterior distribution based on the Bayes’ rule is given by
\begin{equation}\label{eq:bayesrulepost}
	\mathbb{P}(\mathbf{w}|\mathbf{y})=\frac{\mathbb{P}(\mathbf{w})\mathbb{P}(\mathbf{y}|\mathbf{w})}{\mathbb{P}(\mathbf{y})},
\end{equation}
where $\mathbb{P}(\mathbf{w})$ is the &lt;i&gt;a priori&lt;/i&gt; distribution of the parameter, $\mathbb{P}(\mathbf{y}|\mathbf{w})$ is the likelihood, and $\mathbb{P}(\mathbf{y})$ is the normalizing factor. The likelihood is given by
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
    \mathbb{P}(\mathbf{y}|\mathbf{w})&amp;=\prod_{i=1}^{n}\frac{1}{\sqrt{2\pi\alpha^{-1}}}\exp\left[-\frac{\alpha(y_i-\mathbf{w}^{\text{T}}\mathbf{x}_i)^2}{2}\right]\nonumber\\
    &amp;=\left(\frac{\alpha}{2\pi}\right)^{n/2}\exp\left[-\sum_{i=1}^n\frac{\alpha(y_i-\mathbf{w}^{\text{T}}\mathbf{x}_i)^2}{2}\right].\label{eq:likelihood:blreg}
\end{align} %]]&gt;&lt;/script&gt;
In matrix form, this can be written as
\begin{equation}
    \mathbb{P}(\mathbf{y}|\mathbf{w})\propto\exp\left[-\frac{\alpha}{2}(\mathbf{y}-\boldsymbol{\mathfrak{A}}\mathbf{w})^{\text{T}}(\mathbf{y}-\boldsymbol{\mathfrak{A}}\mathbf{w})\right]
\end{equation}
where $\boldsymbol{\mathfrak{A}}=\left[(\mathbf{x}_i^{\text{T}})\right]$, i.e. $\boldsymbol{\mathfrak{A}}\in(\mathbb{R}^{n}\times\mathbb{R}^d)$, this matrix is known as the &lt;i&gt;design matrix&lt;/i&gt;. Given that $\mathbf{w}$ has the following prior distribution
\begin{equation}\label{eq:wpriori}
    \mathbb{P}(\mathbf{w})=\frac{1}{\sqrt{(2\pi)^{d}|\beta^{-1}\mathbf{I}|}}\exp\left[-\frac{1}{2}\mathbf{w}^{\text{T}}\beta\mathbf{I}\mathbf{w}\right],
\end{equation}
implies that the posterior has the following form:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
    \mathbb{P}(\mathbf{w}|\mathbf{y})&amp;\propto\exp\left[-\frac{\alpha}{2}(\mathbf{y}-\boldsymbol{\mathfrak{A}}\mathbf{w})^{\text{T}}(\mathbf{y}-\boldsymbol{\mathfrak{A}}\mathbf{w})\right]\exp\left[-\frac{1}{2}\mathbf{w}^{\text{T}}\beta\mathbf{I}\mathbf{w}\right]\nonumber\\
&amp;=\exp\left\{-\frac{1}{2}\left[\alpha(\mathbf{y}-\boldsymbol{\mathfrak{A}}\mathbf{w})^{\text{T}}(\mathbf{y}-\boldsymbol{\mathfrak{A}}\mathbf{w})+\mathbf{w}^{\text{T}}\beta\mathbf{I}\mathbf{w}\right]\right\}.
\end{align} %]]&gt;&lt;/script&gt;
Expanding the terms in the exponent, becomes
\begin{equation}\label{eq:expterms}
    \alpha\mathbf{y}^{\text{T}}\mathbf{y}-2\alpha\mathbf{w}^{\text{T}}\boldsymbol{\mathfrak{A}}^{\text{T}}\mathbf{y}+\mathbf{w}^{\text{T}}(\alpha\boldsymbol{\mathfrak{A}}^{\text{T}}\boldsymbol{\mathfrak{A}}+\beta\mathbf{I})\mathbf{w}.
\end{equation}
The next step is to complete the square of the above equation such that it resembles the inner terms of the exponential factor of the Gaussian distribution. That is, the quadratic form of the exponential term of a $\mathcal{N}(\mathbf{w}|\boldsymbol{\mu},\boldsymbol{\Sigma}^{-1})$ is given by
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
    (\mathbf{w}-\boldsymbol{\mu})^{\text{T}}\boldsymbol{\Sigma}^{-1}(\mathbf{w}-\boldsymbol{\mu})&amp;=(\mathbf{w}-\boldsymbol{\mu})^{\text{T}}(\boldsymbol{\Sigma}^{-1}\mathbf{w}-\boldsymbol{\Sigma}^{-1}\boldsymbol{\mu})\nonumber\\
&amp;=\mathbf{w}^{\text{T}}\boldsymbol{\Sigma}^{-1}\mathbf{w}-
2\mathbf{w}^{\text{T}}\boldsymbol{\Sigma}^{-1}\boldsymbol{\mu}+\boldsymbol{\mu}^{\text{T}}\boldsymbol{\Sigma}^{-1}\boldsymbol{\mu}.\label{eq:expnorm}
\end{align} %]]&gt;&lt;/script&gt;
The terms in Equation (\ref{eq:expterms}) are matched up with that in (\ref{eq:expnorm}), so that
\begin{equation}\label{eq:sigmablrgauss}
    \boldsymbol{\Sigma}^{-1}=\alpha\boldsymbol{\mathfrak{A}}^{\text{T}}\boldsymbol{\mathfrak{A}}+\beta\mathbf{I}
\end{equation}
and
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
    \mathbf{w}^{\text{T}}\boldsymbol{\Sigma}^{-1}\boldsymbol{\mu}&amp;=\alpha\mathbf{w}^{\text{T}}\boldsymbol{\mathfrak{A}}^{\text{T}}\mathbf{y}\nonumber\\
    \boldsymbol{\Sigma}^{-1}\boldsymbol{\mu}&amp;=\alpha\boldsymbol{\mathfrak{A}}^{\text{T}}\mathbf{y}\nonumber\\
    \boldsymbol{\mu}&amp;=\alpha\boldsymbol{\Sigma}\boldsymbol{\mathfrak{A}}^{\text{T}}\mathbf{y}.\label{eq:mublrgauss}
\end{align} %]]&gt;&lt;/script&gt;
Thus the &lt;i&gt;a posteriori&lt;/i&gt; is a Gaussian distribution with location parameter in Equation (\ref{eq:mublrgauss}) and scale parameter given by the inverse of Equation (\ref{eq:sigmablrgauss}). I’ll leave to the reader the proper mathematical derivation of $\boldsymbol{\mu}$ and $\boldsymbol{\Sigma}$ without matching like what we did above.&lt;/p&gt;
&lt;h3 id=&quot;simulation-experiment&quot;&gt;Simulation Experiment&lt;/h3&gt;
&lt;p&gt;In this section, we are going to apply the theory above using simulated data. I will use Julia as the primary programming language for this article, but I also provided codes for R and Python. To start with, load the following libraries:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-1', 'tabcontent-1')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-1', 'tabcontent-1')&quot;&gt;Python&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-1&quot; class=&quot;tabcontent-1 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/00ac3ea439baddddab166ca40902f4b0.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-1&quot; class=&quot;tabcontent-1&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/e814d09d53a8c3cba1e27d7be4c46d02.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;Next, define the following functions for data simulation and parameter estimation. The estimate of the paramters is governed by the &lt;i&gt;a posteriori&lt;/i&gt; which from above is a multivariate Gaussian distribution, with mean given by Equation (\ref{eq:mublrgauss}) and variance-covariance matrix defined by the inverse of Equation (\ref{eq:sigmablrgauss}).&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-2', 'tabcontent-2')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-2', 'tabcontent-2')&quot;&gt;Python&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'r-2', 'tabcontent-2')&quot;&gt;R&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-2&quot; class=&quot;tabcontent-2 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/df66b766a478aac49c45c2d792184534.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-2&quot; class=&quot;tabcontent-2&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/42c43fe8cbf482e192da1283c0e7756c.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;r-2&quot; class=&quot;tabcontent-2&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/a100a97eaf25659490a01121d1da8fa3.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Execute the above functions and return the necessary values as follows:&lt;/p&gt;
&lt;div class=&quot;tab&quot; style=&quot;margin-bottom: -16px;&quot;&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'julia-3', 'tabcontent-3')&quot;&gt;Julia&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'python-3', 'tabcontent-3')&quot;&gt;Python&lt;/button&gt;
  &lt;button class=&quot;tablinks&quot; onclick=&quot;openCity(event, 'r-3', 'tabcontent-3')&quot;&gt;R&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;julia-3&quot; class=&quot;tabcontent-3 first&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/0a60ea652e1caca60544cea239ccae4b.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;python-3&quot; class=&quot;tabcontent-3&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/5dfa29ebb09275b961806f67e89e5530.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id=&quot;r-3&quot; class=&quot;tabcontent-3&quot; style=&quot;display: none;&quot;&gt;
  &lt;script src=&quot;https://gist.github.com/alstat/5defe8880d40bdbf35ae36688bbcf98a.js&quot;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;Finally, plot the fitted lines whose weights are samples from the &lt;i&gt;a posteriori&lt;/i&gt;. The red line in the plot below is the Maximum &lt;i&gt;A Posteriori&lt;/i&gt; (MAP) of the parameter of interest. Note that, however, the code provided for the animated plot below is Julia. Python and R users can use &lt;a href=&quot;https://matplotlib.org/index.html&quot; target=&quot;_blank&quot;&gt;matplotlib.pyplot&lt;/a&gt; (Julia’s Plots backend) and &lt;a href=&quot;https://github.com/thomasp85/gganimate&quot; target=&quot;_blank&quot;&gt;gganimate&lt;/a&gt;, respectively.
&lt;script src=&quot;https://gist.github.com/alstat/023ff855025d0da2fa50b7923b834fd8.js&quot;&gt;&lt;/script&gt;
&lt;img src=&quot;http://drive.google.com/uc?export=view&amp;amp;id=1XhKHztWM4OpxL1t_KzPxeU1kd40czUvK&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;end-note&quot;&gt;End Note&lt;/h3&gt;
&lt;p&gt;There are many libraries available for Bayesian modeling, for Julia we have: &lt;a href=&quot;https://github.com/JuliaStats/Klara.jl&quot; target=&quot;_blank&quot;&gt;Klara.jl&lt;/a&gt;, &lt;a href=&quot;https://github.com/brian-j-smith/Mamba.jl&quot; target=&quot;_blank&quot;&gt;Mamba.jl&lt;/a&gt;, &lt;a href=&quot;https://github.com/goedman/Stan.jl&quot; target=&quot;_blank&quot;&gt;Stan.jl&lt;/a&gt;, &lt;a href=&quot;https://github.com/TuringLang/Turing.jl&quot; target=&quot;_blank&quot;&gt;Turing.jl&lt;/a&gt; and &lt;a href=&quot;https://juliaobserver.com/categories/Bayesian&quot; target=&quot;_blank&quot;&gt;more related&lt;/a&gt;;
for Python, my favorite is &lt;a href=&quot;https://docs.pymc.io/&quot; target=&quot;_blank&quot;&gt;PyMC3&lt;/a&gt;; and for R, I prefer &lt;a href=&quot;http://mc-stan.org/users/interfaces/rstan&quot; target=&quot;_blank&quot;&gt;RStan&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As always, coding from scratch is a good exercise and it helps you appreciate the math. Further, I found Julia to be quite easy to use as a tool for statistical problems. In fact, Julia’s linear algebra API is very close to the mathematical formulae above.&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bayes, T. (1763). An essay towards solving a problem in the doctrine of chances. &lt;em&gt;Philosophical Transactions&lt;/em&gt;, 53, 370-418. URL: http://www.jstor.org/stable/105741&lt;/li&gt;
  &lt;li&gt;Laplace, P. S. (1986). Memoir on the probability of the causes of events. &lt;em&gt;Statist. Sci.&lt;/em&gt;, 1(3), 364–378. URL: http://dx.doi.org/10.1214/ss/1177013621 doi: 10.1214/ss/1177013621&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;software-versions&quot;&gt;Software Versions&lt;/h3&gt;
&lt;script src=&quot;https://gist.github.com/alstat/53a54b8e96ec1f45883d1447efeab0ff.js&quot;&gt;&lt;/script&gt;</content><author><name>Al-Ahmadgaid B. Asaad</name></author><category term="julia" /><category term="python" /><category term="r" /><summary type="html">Reverend Thomas Bayes (see Bayes, 1763) is known to be the first to formulate the Bayes’ theorem, but the comprehensive mathematical formulation of this result is credited to the works of Laplace (1986). The Bayes’ theorem has the following form: \begin{equation} \label{eq:bayes-theorem} \mathbb{P}(\mathbf{w}|\mathbf{y}) = \frac{\mathbb{P}(\mathbf{w})\mathbb{P}(\mathbf{y}|\mathbf{w})}{\mathbb{P}(\mathbf{y})} \end{equation} where $\mathbf{w}$ is the weight vector and $\mathbf{y}$ is the data. This simple formula is the main foundation of Bayesian modeling. Any model estimated using Maximum Likelihood can be estimated using the above conditional probability. What makes it different, is that the Bayes’ theorem considers uncertainty not only on the observations but also uncertainty on the weights or the objective parameters.</summary></entry><entry><title type="html">Julia: Data Wrangling using JuliaDB.jl and JuliaDBMeta.jl</title><link href="http://localhost:4000/data/analyses/wrangling/julia/programming/packages/2018/06/08/Julia-Introduction-to-Data-Wrangling.html" rel="alternate" type="text/html" title="Julia: Data Wrangling using JuliaDB.jl and JuliaDBMeta.jl" /><published>2018-06-08T12:00:00+08:00</published><updated>2018-06-08T12:00:00+08:00</updated><id>http://localhost:4000/data/analyses/wrangling/julia/programming/packages/2018/06/08/Julia-Introduction-to-Data-Wrangling</id><content type="html" xml:base="http://localhost:4000/data/analyses/wrangling/julia/programming/packages/2018/06/08/Julia-Introduction-to-Data-Wrangling.html">&lt;p&gt;I’m a heavy user of Python’s &lt;a href=&quot;https://pandas.pydata.org/&quot;&gt;pandas&lt;/a&gt; and R’s &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/index.html&quot;&gt;dplyr&lt;/a&gt; both at work and when I was taking my master’s degree. Hands down, both of these tools are very good at handling the data. So what about Julia? It’s a fairly new programming language that’s been around for almost 6 years already with a very active community. If you have no idea, I encourage you to visit &lt;a href=&quot;http://julialang.org/&quot;&gt;Julialang.org&lt;/a&gt;. In summary, it’s a programming language that walks like a &lt;a href=&quot;https://www.python.org/&quot;&gt;Python&lt;/a&gt;, but runs like a &lt;a href=&quot;https://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For data wrangling, there are two packages that we can use, and these are &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames.jl&lt;/a&gt; and &lt;a href=&quot;http://juliadb.org/latest/&quot;&gt;JuliaDB.jl&lt;/a&gt;. Let me reserve a separate post for &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames.jl&lt;/a&gt;, and instead focus on &lt;a href=&quot;http://juliadb.org/latest/&quot;&gt;JuliaDB.jl&lt;/a&gt; and &lt;a href=&quot;https://piever.github.io/JuliaDBMeta.jl/latest/&quot;&gt;JuliaDBMeta.jl&lt;/a&gt; (an alternative for querying the data, like that of R’s &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/index.html&quot;&gt;dplyr&lt;/a&gt;) packages.&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Package Installation&lt;/h3&gt;
&lt;p&gt;By default, the libraries I mentioned above are not built-in in Julia, and hence we need to install it:
&lt;script src=&quot;https://gist.github.com/alstat/78138748ba87580653416a6181693caa.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Data: nycflights13&lt;/h3&gt;
&lt;p&gt;In order to compare Julia’s capability on data wrangling with that of R’s &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/index.html&quot;&gt;dplyr&lt;/a&gt;, we’ll reproduce the example in this &lt;a href=&quot;https://cran.rstudio.com/web/packages/dplyr/vignettes/dplyr.html&quot;&gt;site&lt;/a&gt;. It uses all 336,776 flights that departed from New York City in 2013. I have a copy of it on github, and the following will download and load the data:
&lt;script src=&quot;https://gist.github.com/alstat/c0c2bc4e5355ac55ad83fc07fa8561c8.js&quot;&gt;&lt;/script&gt;
The rows of the data are not displayed as we execute &lt;code&gt;nycflights&lt;/code&gt; in line 7, that’s because we have a lot of columns, and by default &lt;a href=&quot;http://juliadb.org/latest/&quot;&gt;JuliaDB.jl&lt;/a&gt; will not print all these unless you have a big display (unfortunately, I’m using my 13 inch laptop screen, and that’s why). Hence, for the rest of the article, we’ll be using selected columns only:
&lt;script src=&quot;https://gist.github.com/alstat/2cde6bb6e7ede38ddcdba7d47fb1fed7.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Filter Rows&lt;/h3&gt;
&lt;p&gt;Filtering is a row-wise operation and is done using the &lt;code&gt;Base.filter&lt;/code&gt; function with extended method for &lt;code&gt;JuliaDB.IndexedTables&lt;/code&gt;.
Therefore, to filter the data for month equal to 1 (January) and day equal to 1 (first day of the month), is done as follows:
&lt;script src=&quot;https://gist.github.com/alstat/fe17e7133a3de644bfc853b624bb6af3.js&quot;&gt;&lt;/script&gt;
To see the output for line 2 using &lt;code&gt;Base.filter&lt;/code&gt;, simply remove the semicolon and you’ll have the same output as that of line 5 (using &lt;code&gt;JuliaDBMeta.@filter&lt;/code&gt;).&lt;/p&gt;

&lt;h3 class=&quot;section&quot;&gt;Arrange Rows&lt;/h3&gt;
&lt;p&gt;To arrange the rows of the columns, use &lt;code&gt;Base.sort&lt;/code&gt; function:
&lt;script src=&quot;https://gist.github.com/alstat/1211792bac2febc1d7c4ba058107e2d9.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Select Columns&lt;/h3&gt;
&lt;p&gt;We’ve seen above how to select the columns, but we can also use ranges of columns for selection.
&lt;script src=&quot;https://gist.github.com/alstat/785e35fe4535c84cc8f60dafa9b39e69.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Rename Column&lt;/h3&gt;
&lt;p&gt;To rename the column, use &lt;code&gt;JuliaDB.renamecol&lt;/code&gt; function:
&lt;script src=&quot;https://gist.github.com/alstat/048463d348450873dba81f3a96a473d1.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Add New Column&lt;/h3&gt;
&lt;p&gt;To add a new column, use &lt;code&gt;insertcol&lt;/code&gt;, &lt;code&gt;insertcolafter&lt;/code&gt; and &lt;code&gt;insertcolbefore&lt;/code&gt; of the &lt;a href=&quot;http://juliadb.org/latest/&quot;&gt;JuliaDB.jl&lt;/a&gt;.
&lt;script src=&quot;https://gist.github.com/alstat/a5a2df1fbdb3feaad408a2ca92244e30.js&quot;&gt;&lt;/script&gt;
or use the &lt;code&gt;@transform&lt;/code&gt; macro of the &lt;a href=&quot;https://piever.github.io/JuliaDBMeta.jl/latest/&quot;&gt;JuliaDBMeta.jl&lt;/a&gt;:
&lt;script src=&quot;https://gist.github.com/alstat/ee7f0ab8405473aa88c5f52193ede352.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Summarize Data&lt;/h3&gt;
&lt;p&gt;The data can be summarized using the &lt;code&gt;JuliaDB.summarize&lt;/code&gt; function
&lt;script src=&quot;https://gist.github.com/alstat/3891fec973a923dcc0f6cc451ead4859.js&quot;&gt;&lt;/script&gt;
&lt;code&gt;@with&lt;/code&gt; macro is an alternative from &lt;a href=&quot;https://piever.github.io/JuliaDBMeta.jl/latest/&quot;&gt;JuliaDBMeta.jl&lt;/a&gt;.&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Grouped Operations&lt;/h3&gt;
&lt;p&gt;For grouped operations, we can use the &lt;code&gt;JuliaDB.groupby&lt;/code&gt; function or the &lt;code&gt;JuliaDBMeta.@groupby&lt;/code&gt;:
&lt;script src=&quot;https://gist.github.com/alstat/523976efd34a747f8fe6211b16ad6bf0.js&quot;&gt;&lt;/script&gt;
We’ll use the summarized data above and plot the flight delay in relation to the distance travelled. We’ll use the &lt;a href=&quot;http://gadflyjl.org/stable/&quot;&gt;Gadfly.jl&lt;/a&gt; package for plotting and &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames.jl&lt;/a&gt; for converting &lt;a href=&quot;http://juliadb.org/latest/&quot;&gt;JuliaDB.jl&lt;/a&gt;’s IndexedTable objects to DataFrames.DataFrame object, that’s because Gadfly.plot has no direct method for JuliaDB.IndexedTables.
&lt;script src=&quot;https://gist.github.com/alstat/c8485c39992d82c9129ccd2e5e2745c2.js&quot;&gt;&lt;/script&gt;
To plot, run the following:
&lt;script src=&quot;https://gist.github.com/alstat/2d6322571f78ec940af76c6011ed9f1f.js&quot;&gt;&lt;/script&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/estadistika/assets/master/imgs/2018-6-8-p2.svg?sanitize=true&quot; /&gt;
To find the number of planes and the number of flights that go to each possible destination, run:
&lt;script src=&quot;https://gist.github.com/alstat/6a78c1dc19914326c39a4c47eecb7b8e.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Piping Multiple Operations&lt;/h3&gt;
&lt;p&gt;For multiple operations, it is convenient to use piping and that is the reason why we have tools like &lt;a href=&quot;https://piever.github.io/JuliaDBMeta.jl/latest/&quot;&gt;JuliaDBMeta.jl&lt;/a&gt;. The following example using &lt;a href=&quot;https://cran.rstudio.com/web/packages/dplyr/vignettes/dplyr.html&quot;&gt;R’s dplyr&lt;/a&gt;:
&lt;script src=&quot;https://gist.github.com/alstat/1ef5992f368ebdb4be5e8b95678e6021.js&quot;&gt;&lt;/script&gt;
is equivalent to the following Julia code using &lt;a href=&quot;https://piever.github.io/JuliaDBMeta.jl/latest/&quot;&gt;JuliaDBMeta.jl&lt;/a&gt;:
&lt;script src=&quot;https://gist.github.com/alstat/a91f46846a8bc6ef0ac2992293734f90.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 class=&quot;section&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;I’ve demonstrated how easy it is to use Julia for doing data wrangling, and I love it. In fact, there is a library that can query any table-like data structure in Julia, and is called &lt;a href=&quot;https://github.com/davidanthoff/Query.jl&quot;&gt;Query.jl&lt;/a&gt; (will definitely write a separate article for this in the future).&lt;/p&gt;

&lt;p&gt;For more on &lt;a href=&quot;http://juliadb.org/latest/&quot;&gt;JuliaDB.jl&lt;/a&gt;, watch the &lt;a href=&quot;https://www.youtube.com/watch?v=d5SzUh2_ono&quot;&gt;Youtube tutorial&lt;/a&gt;.&lt;/p&gt;</content><author><name>Al-Ahmadgaid B. Asaad</name></author><category term="julia" /><summary type="html">I’m a heavy user of Python’s pandas and R’s dplyr both at work and when I was taking my master’s degree. Hands down, both of these tools are very good at handling the data. So what about Julia? It’s a fairly new programming language that’s been around for almost 6 years already with a very active community. If you have no idea, I encourage you to visit Julialang.org. In summary, it’s a programming language that walks like a Python, but runs like a C.</summary></entry></feed>